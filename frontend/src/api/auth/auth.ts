/**
 * Generated by orval v7.11.2 ðŸº
 * Do not edit manually.
 * FastAPI
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  BearerResponse,
  BodyAuthJwtLoginAuthJwtLoginPost,
  BodyResetForgotPasswordAuthForgotPasswordPost,
  BodyResetResetPasswordAuthResetPasswordPost,
  BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
  BodyVerifyVerifyAuthVerifyPost,
  ErrorModel,
  HTTPValidationError,
  UserCreate,
  UserRead
} from '../generated.schemas';

import { apiClient } from '../../lib/axios';




/**
 * @summary Auth:Jwt.Login
 */
export const authJwtLoginAuthJwtLoginPost = (
    bodyAuthJwtLoginAuthJwtLoginPost: BodyAuthJwtLoginAuthJwtLoginPost,
 signal?: AbortSignal
) => {
      
      const formUrlEncoded = new URLSearchParams();
if(bodyAuthJwtLoginAuthJwtLoginPost.grant_type !== undefined && bodyAuthJwtLoginAuthJwtLoginPost.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyAuthJwtLoginAuthJwtLoginPost.grant_type)
 }
formUrlEncoded.append(`username`, bodyAuthJwtLoginAuthJwtLoginPost.username)
formUrlEncoded.append(`password`, bodyAuthJwtLoginAuthJwtLoginPost.password)
if(bodyAuthJwtLoginAuthJwtLoginPost.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyAuthJwtLoginAuthJwtLoginPost.scope)
 }
if(bodyAuthJwtLoginAuthJwtLoginPost.client_id !== undefined && bodyAuthJwtLoginAuthJwtLoginPost.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyAuthJwtLoginAuthJwtLoginPost.client_id)
 }
if(bodyAuthJwtLoginAuthJwtLoginPost.client_secret !== undefined && bodyAuthJwtLoginAuthJwtLoginPost.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyAuthJwtLoginAuthJwtLoginPost.client_secret)
 }

      return apiClient<BearerResponse>(
      {url: `/auth/jwt/login`, method: 'POST',
      headers: {'Content-Type': 'application/x-www-form-urlencoded', },
       data: formUrlEncoded, signal
    },
      );
    }
  


export const getAuthJwtLoginAuthJwtLoginPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext> => {

const mutationKey = ['authJwtLoginAuthJwtLoginPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, {data: BodyAuthJwtLoginAuthJwtLoginPost}> = (props) => {
          const {data} = props ?? {};

          return  authJwtLoginAuthJwtLoginPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLoginAuthJwtLoginPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>>
    export type AuthJwtLoginAuthJwtLoginPostMutationBody = BodyAuthJwtLoginAuthJwtLoginPost
    export type AuthJwtLoginAuthJwtLoginPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Auth:Jwt.Login
 */
export const useAuthJwtLoginAuthJwtLoginPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>, TError,{data: BodyAuthJwtLoginAuthJwtLoginPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLoginAuthJwtLoginPost>>,
        TError,
        {data: BodyAuthJwtLoginAuthJwtLoginPost},
        TContext
      > => {

      const mutationOptions = getAuthJwtLoginAuthJwtLoginPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Auth:Jwt.Logout
 */
export const authJwtLogoutAuthJwtLogoutPost = (
    
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/auth/jwt/logout`, method: 'POST', signal
    },
      );
    }
  


export const getAuthJwtLogoutAuthJwtLogoutPostMutationOptions = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext> => {

const mutationKey = ['authJwtLogoutAuthJwtLogoutPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, void> = () => {
          

          return  authJwtLogoutAuthJwtLogoutPost()
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AuthJwtLogoutAuthJwtLogoutPostMutationResult = NonNullable<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>>
    
    export type AuthJwtLogoutAuthJwtLogoutPostMutationError = null

    /**
 * @summary Auth:Jwt.Logout
 */
export const useAuthJwtLogoutAuthJwtLogoutPost = <TError = null,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>, TError,void, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof authJwtLogoutAuthJwtLogoutPost>>,
        TError,
        void,
        TContext
      > => {

      const mutationOptions = getAuthJwtLogoutAuthJwtLogoutPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Register:Register
 */
export const registerRegisterAuthRegisterPost = (
    userCreate: UserCreate,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `/auth/register`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: userCreate, signal
    },
      );
    }
  


export const getRegisterRegisterAuthRegisterPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['registerRegisterAuthRegisterPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  registerRegisterAuthRegisterPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type RegisterRegisterAuthRegisterPostMutationResult = NonNullable<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>>
    export type RegisterRegisterAuthRegisterPostMutationBody = UserCreate
    export type RegisterRegisterAuthRegisterPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Register:Register
 */
export const useRegisterRegisterAuthRegisterPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>, TError,{data: UserCreate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof registerRegisterAuthRegisterPost>>,
        TError,
        {data: UserCreate},
        TContext
      > => {

      const mutationOptions = getRegisterRegisterAuthRegisterPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Reset:Forgot Password
 */
export const resetForgotPasswordAuthForgotPasswordPost = (
    bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/auth/forgot-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetForgotPasswordAuthForgotPasswordPost, signal
    },
      );
    }
  


export const getResetForgotPasswordAuthForgotPasswordPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext> => {

const mutationKey = ['resetForgotPasswordAuthForgotPasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, {data: BodyResetForgotPasswordAuthForgotPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetForgotPasswordAuthForgotPasswordPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetForgotPasswordAuthForgotPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>>
    export type ResetForgotPasswordAuthForgotPasswordPostMutationBody = BodyResetForgotPasswordAuthForgotPasswordPost
    export type ResetForgotPasswordAuthForgotPasswordPostMutationError = HTTPValidationError

    /**
 * @summary Reset:Forgot Password
 */
export const useResetForgotPasswordAuthForgotPasswordPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>, TError,{data: BodyResetForgotPasswordAuthForgotPasswordPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetForgotPasswordAuthForgotPasswordPost>>,
        TError,
        {data: BodyResetForgotPasswordAuthForgotPasswordPost},
        TContext
      > => {

      const mutationOptions = getResetForgotPasswordAuthForgotPasswordPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Reset:Reset Password
 */
export const resetResetPasswordAuthResetPasswordPost = (
    bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/auth/reset-password`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyResetResetPasswordAuthResetPasswordPost, signal
    },
      );
    }
  


export const getResetResetPasswordAuthResetPasswordPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext> => {

const mutationKey = ['resetResetPasswordAuthResetPasswordPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, {data: BodyResetResetPasswordAuthResetPasswordPost}> = (props) => {
          const {data} = props ?? {};

          return  resetResetPasswordAuthResetPasswordPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ResetResetPasswordAuthResetPasswordPostMutationResult = NonNullable<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>>
    export type ResetResetPasswordAuthResetPasswordPostMutationBody = BodyResetResetPasswordAuthResetPasswordPost
    export type ResetResetPasswordAuthResetPasswordPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Reset:Reset Password
 */
export const useResetResetPasswordAuthResetPasswordPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>, TError,{data: BodyResetResetPasswordAuthResetPasswordPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof resetResetPasswordAuthResetPasswordPost>>,
        TError,
        {data: BodyResetResetPasswordAuthResetPasswordPost},
        TContext
      > => {

      const mutationOptions = getResetResetPasswordAuthResetPasswordPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Verify:Request-Token
 */
export const verifyRequestTokenAuthRequestVerifyTokenPost = (
    bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<unknown>(
      {url: `/auth/request-verify-token`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyRequestTokenAuthRequestVerifyTokenPost, signal
    },
      );
    }
  


export const getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext> => {

const mutationKey = ['verifyRequestTokenAuthRequestVerifyTokenPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, {data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyRequestTokenAuthRequestVerifyTokenPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>>
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationBody = BodyVerifyRequestTokenAuthRequestVerifyTokenPost
    export type VerifyRequestTokenAuthRequestVerifyTokenPostMutationError = HTTPValidationError

    /**
 * @summary Verify:Request-Token
 */
export const useVerifyRequestTokenAuthRequestVerifyTokenPost = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>, TError,{data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyRequestTokenAuthRequestVerifyTokenPost>>,
        TError,
        {data: BodyVerifyRequestTokenAuthRequestVerifyTokenPost},
        TContext
      > => {

      const mutationOptions = getVerifyRequestTokenAuthRequestVerifyTokenPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    /**
 * @summary Verify:Verify
 */
export const verifyVerifyAuthVerifyPost = (
    bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost,
 signal?: AbortSignal
) => {
      
      
      return apiClient<UserRead>(
      {url: `/auth/verify`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: bodyVerifyVerifyAuthVerifyPost, signal
    },
      );
    }
  


export const getVerifyVerifyAuthVerifyPostMutationOptions = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext> => {

const mutationKey = ['verifyVerifyAuthVerifyPost'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, {data: BodyVerifyVerifyAuthVerifyPost}> = (props) => {
          const {data} = props ?? {};

          return  verifyVerifyAuthVerifyPost(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VerifyVerifyAuthVerifyPostMutationResult = NonNullable<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>>
    export type VerifyVerifyAuthVerifyPostMutationBody = BodyVerifyVerifyAuthVerifyPost
    export type VerifyVerifyAuthVerifyPostMutationError = ErrorModel | HTTPValidationError

    /**
 * @summary Verify:Verify
 */
export const useVerifyVerifyAuthVerifyPost = <TError = ErrorModel | HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>, TError,{data: BodyVerifyVerifyAuthVerifyPost}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof verifyVerifyAuthVerifyPost>>,
        TError,
        {data: BodyVerifyVerifyAuthVerifyPost},
        TContext
      > => {

      const mutationOptions = getVerifyVerifyAuthVerifyPostMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    